#!/usr/bin/env python3
import datetime
import os
import logging

log = logging.getLogger()

DEST_OVERRIDES = {
    'sublime_text': 'Library/Application Support/Sublime Text 3/Packages/User/'
}


def create_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a small
    race condition here but if the race condition fails and a path exists at the
    target by the time we go to move something there, the move will simply fail

    """
    d = datetime.datetime.now().isoformat()

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak.' + d

    return path


def symlink_files(source_dir, dest_dir):
    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        # default to the provided dest_dir, otherwise use the override
        dest_dir_override = dest_dir
        if file in DEST_OVERRIDES:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, DEST_OVERRIDES[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

        repo_path = os.path.join(source_dir, file)
        dest_path = os.path.join(dest_dir_override, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            # if the file exists, it's ok to overwrite if it's already a symlink
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink. Overwriting".format(dest_path))
                os.remove(dest_path)
            else:
                # move to backup location before proceeding
                backup_path = create_backup_path(dest_path)
                log.info("Destination exists at {!r}. Renaming to {!r}".format(
                    dest_path, backup_path))

                os.rename(dest_path, backup_path)

        os.symlink(repo_path, dest_path)


if __name__ == '__main__':
    # todo: support setting debug level from command line?
    logging.basicConfig(level=logging.INFO)

    # for all files and directories within $repo/HOME/,
    # symlink them into $HOME unless it's in NON_HOME
    # this setup program lives in $repo/HOME/bin/, which should be symlinked to
    # $HOME/bin, so $repo/HOME/bin/../.. will get the root of the repository
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    home_dir = os.path.expanduser('~')
    symlink_files(repo_home_dir, home_dir)
