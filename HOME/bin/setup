#!/usr/bin/env python3
import abc
import argparse
import code
import datetime
import fnmatch
import getpass
import io
import os
import pwd
import re
import shutil
import subprocess
import zipfile
from collections import OrderedDict
from copy import copy
from distutils.util import strtobool
from functools import partial

import logging
log = logging.getLogger()

SETTINGS_FILE_LOCATION = 'settings.py'


def get_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a
    small race condition (where a file is created at the backup path you
    specify before you move the file there but after this determines the backup
    path), but that's not worth handling.

    """
    d = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak' + d

    return path


def create_symlinks(symlink_settings, source_dir, dest_dir):
    """
    For all files and directories within source_dir, symlink them into dest_dir.

    The destination in the dest_dir defaults to its location in the source_dir
    unless it's overridden in symlink_settings['overrides'].

    """
    overrides = symlink_settings['overrides']
    ignores = symlink_settings['ignores']

    # ignores_file = symlink_settings['ignores_file']
    #
    # if os.path.exists(ignores_file):
    #     ignores = list(filter(None, open(ignores_file).read().splitlines()))
    # else:
    #     path = os.path.join(os.getcwd(), ignores_file)
    #     log.warning("Couldn't read ignores file at {!r}".format(path))
    #     ignores = []

    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        if any(fnmatch.fnmatch(file, ignore) for ignore in ignores):
            log.debug("{!r} is ignored".format(file))
            continue

        # default to the provided dest_dir, otherwise use the override
        if file in overrides:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, overrides[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

            dest_path = dest_dir_override
        else:
            dest_path = os.path.join(dest_dir, file)

        repo_path = os.path.join(source_dir, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink.".format(dest_path))
                prior_symlink = os.readlink(dest_path)
                if prior_symlink == repo_path:
                    log.debug("{!r} already points where we want, making no changes".format(
                        dest_path))
                else:
                    log.info("Changing symlink at {!r} to point to {!r}. "
                             "Currently points to {!r}".format(
                                 dest_path, repo_path, prior_symlink))

                    os.remove(dest_path)
                    os.symlink(repo_path, dest_path)
            else:
                # move to backup location before proceeding
                backup_path = get_backup_path(dest_path)
                log.info("Renaming {!r} to {!r}".format(dest_path, backup_path))
                os.rename(dest_path, backup_path)

                log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
                os.symlink(repo_path, dest_path)
        else:
            log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
            os.symlink(repo_path, dest_path)


def create_command_line_parser(actions):
    """
    Create and return a command line parser configured with 'actions'

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    gs = globals()  # to resolve the function names specified in actions
    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=gs[params['func']])
        args = params.get('args', ())
        for (name, params) in args:
            add_arg = partial(subparser.add_argument, name, help=params['help'])
            if params.get('optional', False):
                add_arg = partial(add_arg, nargs='?')

            add_arg()

    return parser


def repo(action, settings, *args, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug("cmd is {!r} and kwargs is: {!r}".format(cmd, kwargs))
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def ensure_correct_usrlocal_permissions(*args, **kwargs):
    user = getpass.getuser()
    uid = os.stat('/usr/local').st_uid
    local_owner = pwd.getpwuid(uid).pw_name

    log.debug("Currently logged in user is {!r}, owner of /usr/local is {!r}".format(
        user, local_owner))

    if user != local_owner:
        log.info("Fixing permissions on /usr/local before running Homebrew")
        # stupid that there's a shutil.chown but no shutil.chown -R
        cmd = ['sudo', 'chown', '-R', user, '/usr/local']
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)


def brew(action, settings, *args, **kwargs):
    # ensure homebrew is installed
    if not shutil.which('brew'):  # hey look 'which' is built in as of Python 3.3
        # todo: install homebrew if not installed
        # http://brew.sh/
        # ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        raise Exception("Homebrew must be installed")

    if kwargs.get('fix_repo', False):
        # http://stackoverflow.com/questions/14113427/brew-update-failed
        log.info("Fixing Homebrew repository")
        cmd = 'cd `brew --prefix`; git reset --hard origin/master'
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd, shell=True)

    formulas = settings['homebrew']['formulas']

    # fix permissions on /usr/local if necessary
    ensure_correct_usrlocal_permissions()

    # ensure homebrew updated
    log.info("Running 'brew update'")
    subprocess.check_call(['brew', 'update'])

    # upgrade all existing packages
    log.info("Running 'brew upgrade'")
    subprocess.call(['brew', 'upgrade', '--all'])
    # ideally this would be check_call but homebrew returns an error code in cases that
    # aren't actually errors: https://github.com/Homebrew/homebrew/issues/27048
    # so, make sure to inspect the output for problems

    # ensure expected packages are installed
    log.info("Expected packages are: {}".format(', '.join(sorted(formulas))))
    # bytes.decode defaults to utf-8, which *should* also be the default system encoding
    # but I suppose to really do this correctly I should check that. However, pretty sure
    # all Homebrew package names should be ascii anyway so it's fine
    installed_packages = subprocess.check_output(['brew', 'list']).decode().split()
    log.info("Currently installed packages are: {}".format(', '.join(installed_packages)))

    missing_packages = sorted(set(formulas) - set(installed_packages))
    log.info("Missing packages are: {}".format(', '.join(missing_packages)))

    for p in missing_packages:
        log.info("Installing package: {}".format(p))
        subprocess.check_call(['brew', 'install', p])

    # run post-install operations
    post_install = settings['homebrew']['post_install']
    if post_install:
        log.info("Running post-install operations")

    for cmd in post_install:
        # only if the item is a string, run it with shell=True
        shell = isinstance(cmd, str)
        log.info("Running cmd (shell={!r}): {!r}".format(shell, cmd))
        subprocess.check_call(cmd, shell=shell)


def packages(action, settings, *args, **kwargs):
    log.info("Installing/upgrading language-specific packages")
    for language, params in sorted(settings['packages'].items()):
        log.info("Installing/upgrading packages for: {}".format(language))
        for package in params['packages']:
            log.info("Installing/upgrading package: {}".format(package))
            cmd = [c.format(package=package) for c in params['cmd']]
            subprocess.check_call(cmd)


def addons(action, settings, *args, **kwargs):
    log.info("Installing addons")
    for type, params in settings['addons'].items():
        log.info("Installing addons for {!r}".format(type))
        for addon in params['addons']:
            log.info("Downloading addon {!r}".format(addon))
            result = addon_install(type, addon, params['installation_path'])
            if result:
                log.info("Successfully installed {!r}".format(addon))
            else:
                log.warning("Couldn't install {!r}".format(addon))

    log.info("Finished installing addons")


def addon_install(type, name, installation_path):
    import requests

    uri_pattern = 'http://www.curse.com/addons/wow/{}/download'

    # get the download page
    log.debug("Requesting download page for {!r}".format(name))
    response = requests.get(uri_pattern.format(name))
    if response.status_code != 200:
        log.warning("Error getting download page for {}".format(name))
        return False

    # parse out the download link
    # download links look like:
    # <p>If your download doesn't begin <a data-project="4872" data-file="887016" data-href="http://addons.curse.cursecdn.com/files/887/16/Recount-v6.2.0f_release.zip" class="download-link" href="#">click here</a>.</p>
    log.debug("Parsing out download uri")
    regex = r'<a\s+.*?data-href="([^"]+)".*?class="download-link"'
    match = re.search(regex, response.text)
    download_uri = match.group(1)

    # download the addon
    log.debug("Downloading from {!r}".format(download_uri))
    response = requests.get(download_uri)
    if response.status_code != 200:
        return False

    log.debug("Extracting zip content to {!r}".format(installation_path))
    try:
        file = io.BytesIO(response.content)
        zfile = zipfile.ZipFile(file)
        zfile.extractall(installation_path)
    except:
        log.exception("Couldn't extract files for {!r}".format(name))
        return False

    return True


class mybool(metaclass=abc.ABCMeta):
    """
    Provide something that will parse '0' as False
    because that's how 'defaults' returns false values

    """
    def __new__(self, value='0'):
        return bool(strtobool(value))

mybool.register(bool)


# map 'defaults' types to Python's types
# Use OrderedDict because isinstance(True, int) is True, so compare to bool first
DEFAULTS_TO_PYTHON_TYPE = OrderedDict((
    ('boolean', mybool),
    ('integer', int),
    ('float', float),
    ('string', str),
))


def defaults_read(domain, key, missing_ok=False):
    cmd = ['defaults', 'read-type', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    try:
        result = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        output = e.output.decode()  # bytes -> string
        log.warning("Error reading setting {}:{}. Return code {}, output was: {}".format(
            domain, key, e.returncode, output))

        if 'does not exist' in output:
            log.warning("Prior value for {}:{} doesn't exist".format(domain, key))
            if missing_ok:
                return None

        raise

    log.debug("Result was: {!r}".format(result))

    result_type = re.match('Type is (\w+)', result.decode()).group(1)
    type = DEFAULTS_TO_PYTHON_TYPE[result_type]

    cmd = ['defaults', 'read', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    result = subprocess.check_output(cmd)
    typed_result = type(result.decode().rstrip('\n'))
    log.debug("Result was: {!r}, typed_result was {!r}".format(result, typed_result))
    return typed_result


def defaults_write(domain, key, value):
    cmd = ['defaults', 'write', domain, key]

    for type_str, type in DEFAULTS_TO_PYTHON_TYPE.items():
        if isinstance(value, type):
            break
    else:
        raise Exception("Unsupported value type provided to defaults_write: {!r}".format(value))

    cmd.extend(['-{}'.format(type_str), str(value)])

    log.debug("Executing command: {!r}".format(cmd))
    subprocess.check_call(cmd)


def update_os_settings(settings):
    # useful resources
    # https://github.com/mathiasbynens/dotfiles/blob/master/.osx

    # defaults read | pbcopy to get a list of all current settings

    defaults = settings['osx']['defaults']
    for domain, settings in sorted(defaults.items()):
        for key, value in sorted(settings.items()):
            old_value = defaults_read(domain, key, missing_ok=True)

            if old_value != value:
                log.info("Setting new value for {}:{}. Old value: {!r}, new value: {!r}.".format(
                    domain, key, old_value, value))

            defaults_write(domain, key, value)


def restart_os_functions(*args, **kwargs):
    for item in ('Finder', 'Dock', 'SystemUIServer'):
        cmd = ['killall', item]
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)


def debug(*args, **kwargs):
    code.interact(local=globals()),


def edit(*args, **kwargs):
    subprocess.call('$EDITOR .', shell=True)  # works because cwd is set


def resolve_action_aliases(actions):
    # handle aliases
    actions_copy = copy(actions)
    for a, d in actions.items():
        for alias in d.get('aliases', ()):
            actions_copy[alias] = d

    return actions_copy


if __name__ == '__main__':
    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    home_dir = os.path.expanduser('~')

    # get settings and set up command line parser
    settings = eval(open(SETTINGS_FILE_LOCATION).read())
    actions = settings['actions']
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    # set up logging
    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # set requests loglevel
    logging.getLogger('requests').setLevel(logging.WARNING)

    log.debug("Set cwd to {!r}".format(repo_root_dir))
    log.debug("Command line arguments were: {!r}".format(args))

    # actually do stuff
    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        actions = resolve_action_aliases(actions)
        args.func(actions[args.action], settings, **argsdict)
    else:
        create_symlinks(settings['symlinks'], repo_home_dir, home_dir)
        update_os_settings(settings)
