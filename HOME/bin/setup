#!/usr/bin/env python3
import abc
import argparse
import code
import datetime
import getpass
import fnmatch
import os
import pwd
import re
import shutil
import subprocess
from copy import copy

import logging
log = logging.getLogger()

SETTINGS_FILE_LOCATION = 'settings.py'


def get_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a
    small race condition (where a file is created at the backup path you
    specify before you move the file there but after this determines the backup
    path), but that's not worth handling.

    """
    d = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak' + d

    return path


def create_symlinks(symlink_settings, source_dir, dest_dir):
    """
    For all files and directories within source_dir, symlink them into dest_dir.

    The destination in the dest_dir defaults to its location in the source_dir
    unless it's overridden in symlink_settings['overrides'].

    """
    overrides = symlink_settings['overrides']
    ignores = symlink_settings['ignores']

    # ignores_file = symlink_settings['ignores_file']
    #
    # if os.path.exists(ignores_file):
    #     ignores = list(filter(None, open(ignores_file).read().splitlines()))
    # else:
    #     path = os.path.join(os.getcwd(), ignores_file)
    #     log.warning("Couldn't read ignores file at {!r}".format(path))
    #     ignores = []

    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        if any(fnmatch.fnmatch(file, ignore) for ignore in ignores):
            log.debug("{!r} is ignored".format(file))
            continue

        # default to the provided dest_dir, otherwise use the override
        if file in overrides:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, overrides[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

            dest_path = dest_dir_override
        else:
            dest_path = os.path.join(dest_dir, file)

        repo_path = os.path.join(source_dir, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink.".format(dest_path))
                prior_symlink = os.readlink(dest_path)
                if prior_symlink == repo_path:
                    log.debug("{!r} already points where we want, making no changes".format(
                        dest_path))
                else:
                    log.info("Changing symlink at {!r} to point to {!r}. "
                             "Currently points to {!r}".format(
                                 dest_path, repo_path, prior_symlink))

                    os.remove(dest_path)
                    os.symlink(repo_path, dest_path)
            else:
                # move to backup location before proceeding
                backup_path = get_backup_path(dest_path)
                log.info("Renaming {!r} to {!r}".format(dest_path, backup_path))
                os.rename(dest_path, backup_path)

                log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
                os.symlink(repo_path, dest_path)
        else:
            log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
            os.symlink(repo_path, dest_path)


def create_command_line_parser(actions):
    """
    Create and return a command line parser configured with 'actions'

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    gs = globals()  # to resolve the function names specified in actions
    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=gs[params['func']])
        args = params.get('args', {})
        for k, v in args.items():
            subparser.add_argument(k, help=v['help'])

    return parser


def repo(action, settings, *args, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug("cmd is {!r} and kwargs is: {!r}".format(cmd, kwargs))
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def brew(action, settings, *args, **kwargs):
    # ensure homebrew is installed
    if not shutil.which('brew'):  # hey look 'which' is built in as of Python 3.3
        # todo: install homebrew if not installed
        # http://brew.sh/
        # ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        raise Exception("Homebrew must be installed")

    formulas = settings['homebrew']['formulas']

    # fix permissions on /usr/local if necessary
    user = getpass.getuser()
    uid = os.stat('/usr/local').st_uid
    local_owner = pwd.getpwuid(uid).pw_name

    log.debug("Currently logged in user is {!r}, owner of /usr/local is {!r}".format(
        user, local_owner))

    if user != local_owner:
        log.info("Fixing permissions on /usr/local before running Homebrew")
        # stupid that there's a shutil.chown but no shutil.chown -R
        cmd = ['sudo', 'chown', '-R', user, '/usr/local']
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)

    # ensure homebrew updated
    log.info("Running 'brew update'")
    subprocess.check_call(['brew', 'update'])

    # upgrade all existing packages
    log.info("Running 'brew upgrade'")
    subprocess.call(['brew', 'upgrade', '--all'])
    # ideally this would be check_call but homebrew returns an error code in cases that
    # aren't actually errors: https://github.com/Homebrew/homebrew/issues/27048
    # so, make sure to inspect the output for problems

    # ensure expected packages are installed
    log.info("Expected packages are: {}".format(', '.join(sorted(formulas))))
    # bytes.decode defaults to utf-8, which *should* also be the default system encoding
    # but I suppose to really do this correctly I should check that. However, pretty sure
    # all Homebrew package names should be ascii anyway so it's fine
    installed_packages = subprocess.check_output(['brew', 'list']).decode().split()
    log.info("Currently installed packages are: {}".format(', '.join(installed_packages)))

    missing_packages = sorted(set(formulas) - set(installed_packages))
    log.info("Missing packages are: {}".format(', '.join(missing_packages)))

    for p in missing_packages:
        log.info("Installing package: {}".format(p))
        subprocess.check_call(['brew', 'install', p])


class mybool(metaclass=abc.ABCMeta):
    """
    Provide something that will parse '0' as False
    because that's how 'defaults' returns false values

    """
    def __new__(self, value=False):
        if value == '0':
            value = False
        return bool(value)

    @classmethod
    def __subclasshook__(cls, othercls):
        return othercls is bool


PYTHON_TO_DEFAULTS_TYPE_MAPPING = {
    mybool: 'boolean',
    int: 'integer',
    str: 'string',
    float: 'float',
}


def defaults_read(domain, key):
    cmd = ['defaults', 'read-type', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    result = subprocess.check_output(cmd)
    log.debug("Result was: {!r}".format(result))

    # reverse the type mapping to go from strings to Python types
    type_mapping = {s: t for t, s in PYTHON_TO_DEFAULTS_TYPE_MAPPING.items()}
    result_type = re.match('Type is (\w+)', result.decode()).group(1)
    type = type_mapping[result_type]

    cmd = ['defaults', 'read', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    result = subprocess.check_output(cmd)
    typed_result = type(result.decode().rstrip('\n'))
    log.debug("Result was: {!r}, typed_result was {!r}".format(result, typed_result))
    return typed_result


def defaults_write(domain, key, value):
    cmd = ['defaults', 'write', domain, key]

    type = None
    for t, ts in PYTHON_TO_DEFAULTS_TYPE_MAPPING.items():
        if isinstance(value, t):
            type = ts
            break

    if type is None:
        raise Exception("Unsupported value type provided to defaults_write: {!r}".format(value))

    cmd.extend(['-{}'.format(type), str(value)])

    log.debug("Executing command: {!r}".format(cmd))
    subprocess.check_call(cmd)


def update_os_settings(settings):
    # useful resources
    # https://github.com/mathiasbynens/dotfiles/blob/master/.osx

    # defaults read | pbcopy to get a list of all current settings

    defaults = settings['osx']['defaults']
    for domain, settings in sorted(defaults.items()):
        for key, value in sorted(settings.items()):
            old_value = defaults_read(domain, key)
            if old_value != value:
                log.info("Setting new value for {}:{}. Old value: {!r}, new value: {!r}.".format(
                    domain, key, old_value, value))

            defaults_write(domain, key, value)


def restart_os_functions(*args, **kwargs):
    for item in ('Finder', 'Dock', 'SystemUIServer'):
        cmd = ['killall', item]
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)


def debug(*args, **kwargs):
    code.interact(local=globals()),

if __name__ == '__main__':
    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    home_dir = os.path.expanduser('~')

    # get settings and set up command line parser
    settings = eval(open(SETTINGS_FILE_LOCATION).read())
    actions = settings['actions']
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    # set up logging
    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    log.debug("Set cwd to {!r}".format(repo_root_dir))
    log.debug("Command line arguments were: {!r}".format(args))

    # actually do stuff
    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        args.func(actions[args.action], settings, **argsdict)
    else:
        create_symlinks(settings['symlinks'], repo_home_dir, home_dir)
        update_os_settings(settings)
