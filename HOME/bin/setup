#!/usr/bin/env python3
import argparse
import datetime
import getpass
import json
import os
import pwd
import shutil
import subprocess
from copy import copy

import logging
log = logging.getLogger()

# overrides should not have slashes at the end even though it's a directory
# because it refers to the symlink that's created
DEST_OVERRIDES = {
    'sublime_text': 'Library/Application Support/Sublime Text 3/Packages/User'
}

IGNORES = [  # do this for now, piggyback off of .gitignore later
    '.DS_Store'
]


def get_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a
    small race condition (where a file is created at the backup path you
    specify before you move the file there but after this determines the backup
    path), but that's not worth handling.

    """
    d = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak' + d

    return path


def create_symlinks(source_dir, dest_dir):
    """
    For all files and directories within source_dir, symlink them into dest_dir.

    The destination in the dest_dir defaults to its location in the source_dir
    unless it's overridden in DEST_OVERRIDES.

    """

    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        if file in IGNORES:
            log.debug("{!r} is ignored".format(file))
            continue

        # default to the provided dest_dir, otherwise use the override
        if file in DEST_OVERRIDES:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, DEST_OVERRIDES[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

            dest_path = dest_dir_override
        else:
            dest_path = os.path.join(dest_dir, file)

        repo_path = os.path.join(source_dir, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink.".format(dest_path))
                prior_symlink = os.readlink(dest_path)
                if prior_symlink == repo_path:
                    log.debug("{!r} already points where we want, making no changes".format(
                        dest_path))
                else:
                    log.info("Changing symlink at {!r} to point to {!r}. "
                             "Currently points to {!r}".format(
                                 dest_path, repo_path, prior_symlink))

                    os.remove(dest_path)
                    os.symlink(repo_path, dest_path)
            else:
                # move to backup location before proceeding
                backup_path = get_backup_path(dest_path)
                log.info("Renaming {!r} to {!r}".format(dest_path, backup_path))
                os.rename(dest_path, backup_path)

                log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
                os.symlink(repo_path, dest_path)
        else:
            log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
            os.symlink(repo_path, dest_path)


def create_command_line_parser(actions):
    """
    Create and return a command line parser configured with 'actions'

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=params['func'])
        args = params.get('args', {})
        for k, v in args.items():
            subparser.add_argument(k, help=v['help'])

    return parser


def repo(action, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug("cmd is {!r} and kwargs is: {!r}".format(cmd, kwargs))
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def brew(*args, **kwargs):
    # ensure homebrew is installed
    if not shutil.which('brew'):  # hey look 'which' is built in as of Python 3.3
        # todo: install homebrew if not installed
        # http://brew.sh/
        # ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        raise Exception("Homebrew must be installed")

    with open('homebrew.json') as f:
        j = json.load(f)

    formulas = j['formulas']

    # fix permissions on /usr/local if necessary
    user = getpass.getuser()
    uid = os.stat('/usr/local').st_uid
    local_owner = pwd.getpwuid(uid).pw_name

    log.debug("Currently logged in user is {!r}, owner of /usr/local is {!r}".format(
        user, local_owner))

    if user != local_owner:
        log.info("Fixing permissions on /usr/local before running Homebrew")
        # stupid that there's a shutil.chown but no shutil.chown -R
        cmd = ['sudo', 'chown', '-R', user, '/usr/local']
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)

    # ensure homebrew updated
    log.info("Running 'brew update'")
    subprocess.check_call(['brew', 'update'])

    # upgrade all existing packages
    log.info("Running 'brew upgrade'")
    subprocess.call(['brew', 'upgrade', '--all'])
    # ideally this would be check_call but homebrew returns an error code in cases that
    # aren't actually errors: https://github.com/Homebrew/homebrew/issues/27048
    # so, make sure to inspect the output for problems

    # ensure expected packages are installed
    log.info("Expected packages are: {}".format(', '.join(sorted(formulas))))
    # bytes.decode defaults to utf-8, which *should* also be the default system encoding
    # but I suppose to really do this correctly I should check that. However, pretty sure
    # all Homebrew package names should be ascii anyway so it's fine
    installed_packages = subprocess.check_output(['brew', 'list']).decode().split()
    log.info("Currently installed packages are: {}".format(', '.join(installed_packages)))

    missing_packages = sorted(set(formulas) - set(installed_packages))
    log.info("Missing packages are {}".format(', '.join(missing_packages)))

    for p in missing_packages:
        log.info("Installing package: {}".format(p))
        subprocess.check_call(['brew', 'install', p])

actions = {
    'status': {
        'func': repo,
        'cmd': ['status'],
        'help': 'Get repository status'
    },
    'diff': {
        'func': repo,
        'cmd': ['diff'],
        'help': 'Get repository diff'
    },
    'commit': {
        'func': repo,
        'cmd': ['commit', '-am', '{message}'],
        'args': {'message': {'help': 'The commit message'}},
        'help': 'Commit to repository'
    },
    'pull': {
        'func': repo,
        'cmd': ['pull'],
        'help': 'Pull repository from server',
        'aliases': ['update'],
    },
    'push': {
        'func': repo,
        'cmd': ['push'],
        'help': 'Push repository to server'
    },
    'brew': {
        'func': brew,
        # initial space because the beermug takes up two character spaces
        # and overlaps if you don't pad it with a space afterwards
        'help': "\U0001F37A Homebrew\U0001F37A"
    }
}

if __name__ == '__main__':
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    log.debug("Command line arguments were: {!r}".format(args))

    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    log.debug("Set cwd to {!r}".format(repo_root_dir))
    home_dir = os.path.expanduser('~')

    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        args.func(actions[args.action], **argsdict)
    else:
        create_symlinks(repo_home_dir, home_dir)
