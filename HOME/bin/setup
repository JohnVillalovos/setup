#!/usr/bin/env python3
import abc
import argparse
import code
import datetime
import fnmatch
import getpass
import io
import os
import pwd
import re
import shutil
import subprocess
import zipfile
from copy import copy
from functools import partial

import logging
log = logging.getLogger()

from lib import symlink

SETTINGS_FILE_LOCATION = 'settings.py'


def create_command_line_parser(actions):
    """
    Create and return a command line parser configured with 'actions'

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    gs = globals()  # to resolve the function names specified in actions
    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=gs[params['func']])
        args = params.get('args', ())
        for (name, params) in args:
            add_arg = partial(subparser.add_argument, name, help=params['help'])
            if params.get('optional', False):
                add_arg = partial(add_arg, nargs='?')

            add_arg()

    return parser


def repo(action, settings, *args, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug("cmd is {!r} and kwargs is: {!r}".format(cmd, kwargs))
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def brew(action, settings, *args, **kwargs):
    # ensure homebrew is installed
    if not shutil.which('brew'):  # hey look 'which' is built in as of Python 3.3
        # todo: install homebrew if not installed
        # http://brew.sh/
        # ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        raise Exception("Homebrew must be installed")

    if kwargs.get('fix_repo', False):
        # http://stackoverflow.com/questions/14113427/brew-update-failed
        log.info("Fixing Homebrew repository")
        cmd = 'cd `brew --prefix`; git reset --hard origin/master'
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd, shell=True)

    formulas = settings['homebrew']['formulas']

    # fix permissions on /usr/local if necessary
    user = getpass.getuser()
    uid = os.stat('/usr/local').st_uid
    local_owner = pwd.getpwuid(uid).pw_name

    log.debug("Currently logged in user is {!r}, owner of /usr/local is {!r}".format(
        user, local_owner))

    if user != local_owner:
        log.info("Fixing permissions on /usr/local before running Homebrew")
        # stupid that there's a shutil.chown but no shutil.chown -R
        cmd = ['sudo', 'chown', '-R', user, '/usr/local']
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)

    # ensure homebrew updated
    log.info("Running 'brew update'")
    subprocess.check_call(['brew', 'update'])

    # upgrade all existing packages
    log.info("Running 'brew upgrade'")
    subprocess.call(['brew', 'upgrade', '--all'])
    # ideally this would be check_call but homebrew returns an error code in cases that
    # aren't actually errors: https://github.com/Homebrew/homebrew/issues/27048
    # so, make sure to inspect the output for problems

    # ensure expected packages are installed
    log.info("Expected packages are: {}".format(', '.join(sorted(formulas))))
    # bytes.decode defaults to utf-8, which *should* also be the default system encoding
    # but I suppose to really do this correctly I should check that. However, pretty sure
    # all Homebrew package names should be ascii anyway so it's fine
    installed_packages = subprocess.check_output(['brew', 'list']).decode().split()
    log.info("Currently installed packages are: {}".format(', '.join(installed_packages)))

    missing_packages = sorted(set(formulas) - set(installed_packages))
    log.info("Missing packages are: {}".format(', '.join(missing_packages)))

    for p in missing_packages:
        log.info("Installing package: {}".format(p))
        subprocess.check_call(['brew', 'install', p])

    # run post-install operations
    post_install = settings['homebrew']['post_install']
    if post_install:
        log.info("Running post-install operations")

    for cmd in post_install:
        # only if the item is a string, run it with shell=True
        shell = isinstance(cmd, str)
        log.info("Running cmd (shell={!r}): {!r}".format(shell, cmd))
        subprocess.check_call(cmd, shell=shell)


def packages(action, settings, *args, **kwargs):
    log.info("Installing/upgrading language-specific packages")
    for language, params in sorted(settings['packages'].items()):
        log.info("Installing/upgrading packages for: {}".format(language))
        for package in params['packages']:
            log.info("Installing/upgrading package: {}".format(package))
            cmd = [c.format(package=package) for c in params['cmd']]
            subprocess.check_call(cmd)


def addons(action, settings, *args, **kwargs):
    log.info("Installing addons")
    for type, params in settings['addons'].items():
        log.info("Installing addons for {!r}".format(type))
        for addon in params['addons']:
            log.info("Downloading addon {!r}".format(addon))
            result = addon_install(type, addon, params['installation_path'])
            if result:
                log.info("Successfully installed {!r}".format(addon))
            else:
                log.warning("Couldn't install {!r}".format(addon))

    log.info("Finished installing addons")


def addon_install(type, name, installation_path):
    import requests

    uri_pattern = 'http://www.curse.com/addons/wow/{}/download'

    # get the download page
    log.debug("Requesting download page for {!r}".format(name))
    response = requests.get(uri_pattern.format(name))
    if response.status_code != 200:
        log.warning("Error getting download page for {}".format(name))
        return False

    # parse out the download link
    # download links look like:
    # <p>If your download doesn't begin <a data-project="4872" data-file="887016" data-href="http://addons.curse.cursecdn.com/files/887/16/Recount-v6.2.0f_release.zip" class="download-link" href="#">click here</a>.</p>
    log.debug("Parsing out download uri")
    regex = r'<a\s+.*?data-href="([^"]+)".*?class="download-link"'
    match = re.search(regex, response.text)
    download_uri = match.group(1)

    # download the addon
    log.debug("Downloading from {!r}".format(download_uri))
    response = requests.get(download_uri)
    if response.status_code != 200:
        return False

    log.debug("Extracting zip content to {!r}".format(installation_path))
    try:
        file = io.BytesIO(response.content)
        zfile = zipfile.ZipFile(file)
        zfile.extractall(installation_path)
    except:
        log.exception("Couldn't extract files for {!r}".format(name))
        return False

    return True


class mybool(metaclass=abc.ABCMeta):
    """
    Provide something that will parse '0' as False
    because that's how 'defaults' returns false values

    """
    def __new__(self, value=False):
        if value == '0':
            value = False
        return bool(value)

    @classmethod
    def __subclasshook__(cls, othercls):
        return othercls is bool


PYTHON_TO_DEFAULTS_TYPE_MAPPING = {
    mybool: 'boolean',
    int: 'integer',
    str: 'string',
    float: 'float',
}


def defaults_read(domain, key, missing_ok=False):
    cmd = ['defaults', 'read-type', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    try:
        result = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        output = e.output.decode()  # bytes -> string
        log.warning("Error reading setting {}:{}. Return code {}, output was: {}".format(
            domain, key, e.returncode, output))

        if 'does not exist' in output:
            log.warning("Prior value for {}:{} doesn't exist".format(domain, key))
            if missing_ok:
                return None

        raise

    log.debug("Result was: {!r}".format(result))

    # reverse the type mapping to go from strings to Python types
    type_mapping = {s: t for t, s in PYTHON_TO_DEFAULTS_TYPE_MAPPING.items()}
    result_type = re.match('Type is (\w+)', result.decode()).group(1)
    type = type_mapping[result_type]

    cmd = ['defaults', 'read', domain, key]
    log.debug("Executing command: {!r}".format(cmd))
    result = subprocess.check_output(cmd)
    typed_result = type(result.decode().rstrip('\n'))
    log.debug("Result was: {!r}, typed_result was {!r}".format(result, typed_result))
    return typed_result


def defaults_write(domain, key, value):
    cmd = ['defaults', 'write', domain, key]

    type = None
    for t, ts in PYTHON_TO_DEFAULTS_TYPE_MAPPING.items():
        if isinstance(value, t):
            type = ts
            break

    if type is None:
        raise Exception("Unsupported value type provided to defaults_write: {!r}".format(value))

    cmd.extend(['-{}'.format(type), str(value)])

    log.debug("Executing command: {!r}".format(cmd))
    subprocess.check_call(cmd)


def update_os_settings(settings):
    # useful resources
    # https://github.com/mathiasbynens/dotfiles/blob/master/.osx

    # defaults read | pbcopy to get a list of all current settings

    defaults = settings['osx']['defaults']
    for domain, settings in sorted(defaults.items()):
        for key, value in sorted(settings.items()):
            old_value = defaults_read(domain, key, missing_ok=True)

            if old_value != value:
                log.info("Setting new value for {}:{}. Old value: {!r}, new value: {!r}.".format(
                    domain, key, old_value, value))

            defaults_write(domain, key, value)


def restart_os_functions(*args, **kwargs):
    for item in ('Finder', 'Dock', 'SystemUIServer'):
        cmd = ['killall', item]
        log.info("Executing command: {!r}".format(cmd))
        subprocess.check_call(cmd)


def debug(*args, **kwargs):
    code.interact(local=globals()),


def edit(*args, **kwargs):
    subprocess.call('$EDITOR .', shell=True)  # works because cwd is set


def resolve_action_aliases(actions):
    # handle aliases
    actions_copy = copy(actions)
    for a, d in actions.items():
        for alias in d.get('aliases', ()):
            actions_copy[alias] = d

    return actions_copy


if __name__ == '__main__':
    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    home_dir = os.path.expanduser('~')

    # get settings and set up command line parser
    settings = eval(open(SETTINGS_FILE_LOCATION).read())
    actions = settings['actions']
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    # set up logging
    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # set requests loglevel
    logging.getLogger('requests').setLevel(logging.WARNING)

    log.debug("Set cwd to {!r}".format(repo_root_dir))
    log.debug("Command line arguments were: {!r}".format(args))

    # actually do stuff
    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        actions = resolve_action_aliases(actions)
        args.func(actions[args.action], settings, **argsdict)
    else:
        symlink.create(settings['symlinks'], repo_home_dir, home_dir)
        update_os_settings(settings)
