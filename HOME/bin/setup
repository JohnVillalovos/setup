#!/usr/bin/env python3
import argparse
import code
import io
import logging
import os
import re
import subprocess
import zipfile
from copy import copy
from functools import partial

from lib import symlink
from lib.homebrew import ensure_correct_permissions, workflow as brew
from lib.osx import restart_os_functions, update_os_settings

SETTINGS_FILE_LOCATION = 'settings.py'

log = logging.getLogger()


def create_command_line_parser(actions):
    """
    Create and return a command line parser configured with 'actions'

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    gs = globals()  # to resolve the function names specified in actions
    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=gs[params['func']])
        args = params.get('args', ())
        for (name, params) in args:
            add_arg = partial(subparser.add_argument, name, help=params['help'])
            if params.get('optional', False):
                add_arg = partial(add_arg, nargs='?')

            add_arg()

    return parser


def repo(action, settings, *args, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug("cmd is {!r} and kwargs is: {!r}".format(cmd, kwargs))
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def packages(action, settings, *args, **kwargs):
    log.info("Installing/upgrading language-specific packages")
    for language, params in sorted(settings['packages'].items()):
        log.info("Installing/upgrading packages for: {}".format(language))
        for package in params['packages']:
            log.info("Installing/upgrading package: {}".format(package))
            cmd = [c.format(package=package) for c in params['cmd']]
            subprocess.check_call(cmd)


def addons(action, settings, *args, **kwargs):
    log.info("Installing addons")
    for type, params in settings['addons'].items():
        log.info("Installing addons for {!r}".format(type))
        for addon in params['addons']:
            log.info("Downloading addon {!r}".format(addon))
            result = addon_install(type, addon, params['installation_path'])
            if result:
                log.info("Successfully installed {!r}".format(addon))
            else:
                log.warning("Couldn't install {!r}".format(addon))

    log.info("Finished installing addons")


def addon_install(type, name, installation_path):
    import requests

    uri_pattern = 'http://www.curse.com/addons/wow/{}/download'

    # get the download page
    log.debug("Requesting download page for {!r}".format(name))
    response = requests.get(uri_pattern.format(name))
    if response.status_code != 200:
        log.warning("Error getting download page for {}".format(name))
        return False

    # parse out the download link
    # download links look like:
    # <p>If your download doesn't begin <a data-project="4872" data-file="887016" data-href="http://addons.curse.cursecdn.com/files/887/16/Recount-v6.2.0f_release.zip" class="download-link" href="#">click here</a>.</p>
    log.debug("Parsing out download uri")
    regex = r'<a\s+.*?data-href="([^"]+)".*?class="download-link"'
    match = re.search(regex, response.text)
    download_uri = match.group(1)

    # download the addon
    log.debug("Downloading from {!r}".format(download_uri))
    response = requests.get(download_uri)
    if response.status_code != 200:
        return False

    log.debug("Extracting zip content to {!r}".format(installation_path))
    try:
        file = io.BytesIO(response.content)
        zfile = zipfile.ZipFile(file)
        zfile.extractall(installation_path)
    except:
        log.exception("Couldn't extract files for {!r}".format(name))
        return False

    return True


def debug(*args, **kwargs):
    code.interact(local=globals()),


def edit(*args, **kwargs):
    subprocess.call('$EDITOR .', shell=True)  # works because cwd is set


def resolve_action_aliases(actions):
    # handle aliases
    actions_copy = copy(actions)
    for a, d in actions.items():
        for alias in d.get('aliases', ()):
            actions_copy[alias] = d

    return actions_copy


def load_settings():
    return eval(open(SETTINGS_FILE_LOCATION).read())


def main():
    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    log.debug("repo_home_dir is {!r}".format(repo_home_dir))
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    home_dir = os.path.expanduser('~')

    # get settings and set up command line parser
    settings = load_settings()
    actions = settings['actions']
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    # set up logging
    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # set requests loglevel
    logging.getLogger('requests').setLevel(logging.WARNING)

    log.debug("Set cwd to {!r}".format(repo_root_dir))
    log.debug("Command line arguments were: {!r}".format(args))

    # actually do stuff
    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        actions = resolve_action_aliases(actions)
        args.func(actions[args.action], settings, **argsdict)
    else:
        symlink.create(settings['symlinks'], repo_home_dir, home_dir)
        update_os_settings(settings)


if __name__ == '__main__':
    main()
