#!/usr/bin/env python3
import argparse
import datetime
import os
import logging

log = logging.getLogger()

# overrides should not have slashes at the end even though it's a directory
# because it refers to the symlink that's created
DEST_OVERRIDES = {
    'sublime_text': 'Library/Application Support/Sublime Text 3/Packages/User'
}

IGNORES = [  # do this for now, piggyback off of .gitignore later
    '.DS_Store'
]


def create_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a small
    race condition here but if the race condition fails and a path exists at the
    target by the time we go to move something there, the move will simply fail

    """
    d = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak' + d

    return path


def symlink_files(source_dir, dest_dir):
    """
    For all files and directories within source_dir, symlink them into dest_dir.

    The destination in the dest_dir defaults to its location in the source_dir
    unless it's overridden in DEST_OVERRIDES.

    """

    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        if file in IGNORES:
            log.debug("{!r} is ignored")
            continue

        # default to the provided dest_dir, otherwise use the override
        if file in DEST_OVERRIDES:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, DEST_OVERRIDES[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

            dest_path = dest_dir_override
        else:
            dest_path = os.path.join(dest_dir, file)

        repo_path = os.path.join(source_dir, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            # if the file exists, it's ok to overwrite if it's already a symlink
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink. Overwriting".format(dest_path))
                os.remove(dest_path)
            else:
                # move to backup location before proceeding
                backup_path = create_backup_path(dest_path)
                log.info("Destination exists at {!r}. Renaming to {!r}".format(
                    dest_path, backup_path))

                os.rename(dest_path, backup_path)

        os.symlink(repo_path, dest_path)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')
    args = parser.parse_args()

    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    home_dir = os.path.expanduser('~')

    symlink_files(repo_home_dir, home_dir)
