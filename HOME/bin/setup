#!/usr/bin/env python3
import argparse
import datetime
import os
import subprocess
from functools import partial

import logging
log = logging.getLogger()

# overrides should not have slashes at the end even though it's a directory
# because it refers to the symlink that's created
DEST_OVERRIDES = {
    'sublime_text': 'Library/Application Support/Sublime Text 3/Packages/User'
}

IGNORES = [  # do this for now, piggyback off of .gitignore later
    '.DS_Store'
]


def get_backup_path(path):
    """
    Create a backup path given path. Use case is that a file exists at path and
    you want to rename it to (a non-existent) backup path. Obviously there's a
    small race condition (where a file is created at the backup path you
    specify before you move the file there but after this determines the backup
    path), but that's not worth handling.

    """
    d = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')

    while os.path.exists(path):  # keep adding to filename until you get a non-existent one
        # strip a trailing slash so you don't create something like foo/.bak...
        if path[-1] == '/':
            path = path[:-1]

        path += '.bak' + d

    return path


def create_symlinks(source_dir, dest_dir):
    """
    For all files and directories within source_dir, symlink them into dest_dir.

    The destination in the dest_dir defaults to its location in the source_dir
    unless it's overridden in DEST_OVERRIDES.

    """

    files = os.listdir(source_dir)
    log.debug("source_dir is: {!r}, dest_dir is: {!r}".format(source_dir, dest_dir))
    for file in files:
        if file in IGNORES:
            log.debug("{!r} is ignored".format(file))
            continue

        # default to the provided dest_dir, otherwise use the override
        if file in DEST_OVERRIDES:
            # if an override, should still be *within* the dest_dir
            dest_dir_override = os.path.join(dest_dir, DEST_OVERRIDES[file])
            log.debug("Overridden destination for file {!r} is {!r}".format(
                file, dest_dir_override))

            dest_path = dest_dir_override
        else:
            dest_path = os.path.join(dest_dir, file)

        repo_path = os.path.join(source_dir, file)
        log.debug("Linking {!r} to {!r}".format(repo_path, dest_path))
        if os.path.lexists(dest_path):
            log.debug("Path {!r} already exists".format(dest_path))
            if os.path.islink(dest_path):
                log.debug("{!r} is a symlink.".format(dest_path))
                prior_symlink = os.readlink(dest_path)
                if prior_symlink == repo_path:
                    log.debug("{!r} already points where we want, making no changes".format(
                        dest_path))
                else:
                    log.info("Changing symlink at {!r} to point to {!r}. "
                             "Currently points to {!r}".format(
                                 dest_path, repo_path, prior_symlink))

                    os.remove(dest_path)
                    os.symlink(repo_path, dest_path)
            else:
                # move to backup location before proceeding
                backup_path = get_backup_path(dest_path)
                log.info("Renaming {!r} to {!r}".format(dest_path, backup_path))
                os.rename(dest_path, backup_path)

                log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
                os.symlink(repo_path, dest_path)
        else:
            log.info("Creating new symlink of {!r} to {!r}".format(file, dest_path))
            os.symlink(repo_path, dest_path)


repo_actions = {
    # sub_action: None (optional), False (disallowed), True (required)
    'status': {'cmd': ['git', 'status'], 'sub_action': False},
    'diff':   {'cmd': ['git', 'diff'], 'sub_action': False},
    'commit': {'cmd': ['git', 'commit', '-am', None], 'sub_action': True},
    'update': {'cmd': ['git', 'pull'], 'sub_action': False},
    'pull':   {'cmd': ['git', 'pull'], 'sub_action': False},
}


def repo(cwd, action, sub_action=None):
    call = partial(subprocess.call, cwd=cwd)

    params = repo_actions[action]
    if params['sub_action'] is False and sub_action:
        raise Exception("Not allowed to provide sub action for '{}'".format(action))
    elif params['sub_action'] is True and not sub_action:
        raise Exception("Must provide sub action for '{}'".format(action))

    cmd = repo_actions[action]['cmd']
    if sub_action:
        # the sub action position is identified by None in the command, so replace it
        cmd = [i or sub_action for i in cmd]

    call(cmd)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')
    parser.add_argument('action', nargs='?', choices=repo_actions.keys())
    parser.add_argument('sub_action', nargs='?')
    args = parser.parse_args()

    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    home_dir = os.path.expanduser('~')

    if args.action:
        repo(repo_root_dir, args.action, args.sub_action)
    else:
        create_symlinks(repo_home_dir, home_dir)
