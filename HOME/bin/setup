#!/usr/bin/env python3
import argparse
import code
import collections
import io
import itertools
import logging
import os
import re
import subprocess
import zipfile
from copy import copy
from functools import partial

from lib import symlink
from lib.homebrew import ensure_correct_permissions
from lib.osx import brew, restart_os_functions, update_os_settings

SETTINGS_FILE_LOCATION = 'settings.py'

log = logging.getLogger()


def create_command_line_parser(actions):
    """Create and return a command line parser configured with 'actions'."""
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug logging')

    subparsers = parser.add_subparsers(dest='action')

    gs = globals()  # to resolve the function names specified in actions
    for action, params in sorted(actions.items()):
        subparser = subparsers.add_parser(
            action, help=params['help'],
            aliases=params.get('aliases', [])
        )
        subparser.set_defaults(func=gs[params['func']])
        args = params.get('args', ())
        for (name, params) in args:
            add_arg = partial(subparser.add_argument, name, help=params['help'])
            if params.get('optional', False):
                add_arg = partial(add_arg, nargs='?')

            add_arg()

    return parser


def repo(action, settings, *args, **kwargs):
    cmd = ['git'] + action['cmd']
    log.debug(f"cmd is {cmd!r} and kwargs is: {kwargs!r}")
    cmd = [c.format(**kwargs) for c in cmd]
    subprocess.check_call(cmd)


def packages(action, settings, *args, **kwargs):
    log.info("Installing/upgrading language-specific packages")
    for language, params in sorted(settings['packages'].items()):
        log.info(f"Installing/upgrading packages for: {language}")
        for package in params['packages']:
            log.info(f"Installing/upgrading package: {package}")
            cmd = [c.format(package=package) for c in params['cmd']]
            subprocess.check_call(cmd)


def addons(action, settings, *args, **kwargs):
    log.info("Installing addons")
    for type, params in settings['addons'].items():
        log.info(f"Installing addons for {type!r}")
        for addon in params['addons']:
            log.info(f"Downloading addon {addon!r}")
            result = addon_install(type, addon, params['installation_path'])
            if result:
                log.info(f"Successfully installed {addon!r}")
            else:
                log.warning(f"Couldn't install {addon!r}")

    log.info("Finished installing addons")


def addon_install(type, name, installation_path):
    import requests

    uri_pattern = 'http://www.curse.com/addons/wow/{}/download'

    # get the download page
    log.debug(f"Requesting download page for {name!r}")
    response = requests.get(uri_pattern.format(name))
    if response.status_code != 200:
        log.warning(f"Error getting download page for {name}")
        return False

    # parse out the download link
    # download links look like:
    # <p>If your download doesn't begin <a data-project="4872" data-file="887016" data-href="http://addons.curse.cursecdn.com/files/887/16/Recount-v6.2.0f_release.zip" class="download-link" href="#">click here</a>.</p>
    log.debug("Parsing out download uri")
    regex = r'<a\s+.*?data-href="([^"]+)".*?class="download-link"'
    match = re.search(regex, response.text)
    download_uri = match.group(1)

    # download the addon
    log.debug(f"Downloading from {download_uri!r}")
    response = requests.get(download_uri)
    if response.status_code != 200:
        return False

    log.debug(f"Extracting zip content to {installation_path!r}")
    try:
        file = io.BytesIO(response.content)
        zfile = zipfile.ZipFile(file)
        zfile.extractall(installation_path)
    except:
        log.exception(f"Couldn't extract files for {name!r}")
        return False

    return True


def debug(*args, **kwargs):
    code.interact(local=globals()),


def edit(*args, **kwargs):
    subprocess.call('$EDITOR .', shell=True)  # works because cwd is set


class ConflictingAliasError(Exception):
    pass


def resolve_action_aliases(actions):
    """Handle aliases within actions.

    Configured as follows:
    {
        'actions': {
            'pull': {
                'func': 'repo',
                'cmd': ['pull'],
                'help': 'Pull repository from server',
                'aliases': ['update'],
            },
            ...
        }
        ...
    }

    """
    return {**actions, **{alias: a for a in actions.values() for alias in a.get('aliases', ())}}


def settings_validate_aliases(settings):
    actions = settings['actions']
    # an alias is just another name for a command. It can't share a name with an existing command,
    # nor can two commands share an alias.
    # in short, the set of all top-level commands and their aliases must be disjoint from each other
    counter = collections.Counter(
        itertools.chain(actions.keys(), *(v.get('aliases', ()) for v in actions.values())))
    dups = [item for item, count in counter.items() if count > 1]

    if dups:
        raise ConflictingAliasError(f"Conflicting command aliases: {dups!r}")


def load_settings():
    settings = eval(open(SETTINGS_FILE_LOCATION).read())

    # validation
    settings_validate_aliases(settings)

    return settings


def main():
    # this setup program lives in $repo/HOME/bin/, so $repo/HOME/bin/../.. will
    # get the root of the repository. Use realpath to resolve symbolic links
    repo_root_dir = os.path.realpath(os.path.join(os.path.dirname(__file__), '../..'))
    repo_home_dir = os.path.join(repo_root_dir, 'HOME')
    log.debug(f"repo_home_dir is {repo_home_dir!r}")
    os.chdir(repo_root_dir)  # set the cwd to the root of the repository
    home_dir = os.path.expanduser('~')

    # get settings and set up command line parser
    settings = load_settings()
    actions = settings['actions']
    parser = create_command_line_parser(actions)
    args = parser.parse_args()

    # set up logging
    loglevel = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=loglevel)

    # set requests loglevel
    logging.getLogger('requests').setLevel(logging.WARNING)

    log.debug(f"Set cwd to {repo_root_dir!r}")
    log.debug(f"Command line arguments were: {args!r}")

    # actually do stuff
    argsdict = copy(vars(args))
    if 'func' in argsdict:
        del argsdict['action']
        actions = resolve_action_aliases(actions)
        args.func(actions[args.action], settings, **argsdict)
    else:
        symlink.create(settings['symlinks'], repo_home_dir, home_dir)
        update_os_settings(settings)


if __name__ == '__main__':
    main()
